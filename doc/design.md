# CJPM (仓颉包管理器) 设计文档

## 目录
1. [项目概述](#1-项目概述)
2. [系统架构](#2-系统架构)
3. [核心模块设计](#3-核心模块设计)
4. [命令系统实现](#4-命令系统实现)
5. [依赖管理系统](#5-依赖管理系统)
6. [构建系统设计](#6-构建系统设计)
7. [配置管理](#7-配置管理)
8. [性能优化策略](#8-性能优化策略)
9. [安全与合规](#9-安全与合规)
10. [扩展性设计](#10-扩展性设计)


---

## 1. 项目概述

### 1.1 项目愿景
CJPM（Cangjie Package Manager）是仓颉语言的官方包管理工具。当前使用仓颉语言实现，计划用 Kotlin 重构（KCJPM）以提升可维护性、性能和扩展性。

### 1.2 设计原则

#### 1.2.1 现代化
- Kotlin 重构：从仓颉实现迁移到 Kotlin，提升开发效率
- 函数式编程：引入不可变数据结构和函数式设计理念
- 响应式架构：使用事件驱动和异步编程模式

#### 1.2.2 高性能
- 并行构建：支持多核心并行编译
- 智能增量编译：基于文件哈希和依赖分析的增量构建
- 多级缓存：内存缓存、磁盘缓存和网络缓存
- 资源管理：高效的内存和线程管理

#### 1.2.3 安全性
- 依赖验证：校验和验证、安全下载
- 沙箱构建：隔离的构建环境
- 权限控制：细粒度的文件和执行权限管理
- 安全审计：命令注入防护和路径遍历防护

### 1.3 核心功能特性
- **包管理**: 路径依赖、Git 依赖、版本解析、锁文件机制
- **构建系统**: 跨平台编译、增量编译、并行构建、多配置支持
- **工作空间**: 多模块项目管理、统一构建
- **脚本系统**: 构建前后脚本、自定义构建逻辑
- **FFI 支持**: C/C++ 库集成、外部工具链
- **IDE 集成**: IntelliJ IDEA 插件、语言服务器

---

## 2. 系统架构

### 2.1 分层架构设计

```
┌─────────────────────────────────────────┐
│          CLI 接口层 (CLI Layer)          │
│  • 命令行参数解析（argopt）              │
│  • 用户交互和输出格式化                  │
│  • 帮助系统和错误提示                    │
├─────────────────────────────────────────┤
│        命令处理层 (Command Layer)        │
│  • CommandFactory 工厂模式               │
│  • Handle 基类和具体命令实现             │
│  • 参数验证和安全检查                    │
├─────────────────────────────────────────┤
│        业务逻辑层 (Business Layer)       │
│  • 构建编排和依赖解析                    │
│  • 并行构建调度                          │
│  • 测试执行和报告生成                    │
│  • 工作空间管理                          │
├─────────────────────────────────────────┤
│        配置管理层 (Config Layer)         │
│  • TOML 解析器（完整实现）               │
│  • 配置验证和校验                        │
│  • 跨平台配置适配                        │
├─────────────────────────────────────────┤
│        存储缓存层 (Storage Layer)        │
│  • 文件系统操作和权限管理                │
│  • 增量编译缓存                          │
│  • 历史记录和锁文件管理                  │
└─────────────────────────────────────────┘
```

### 2.2 实际模块结构

基于原始实现的模块划分：

**命令模块 (command/)**
- factory.cj - 命令工厂
- common.cj - 通用命令处理逻辑
- build.cj, test.cj, run.cj 等 - 具体命令实现

**配置模块 (config/)**
- config.cj - 核心配置管理
- toml.cj - TOML 集成接口
- dependencies.cj - 依赖配置
- workspace.cj - 工作空间配置
- profile.cj - 构建配置文件
- target.cj - 跨平台目标配置

**实现模块 (implement/)**
- build.cj - 构建核心逻辑
- build_parallel.cj - 并行构建
- dep_model.cj - 依赖模型
- topological_sorting.cj - 依赖排序
- test.cj - 测试实现

**TOML 模块 (toml/)**
- 完整的 TOML 解析器实现
- lexer.cj - 词法分析
- parser.cj - 语法分析
- toml_value.cj - 值类型系统

### 2.3 关键设计模式
- **工厂模式**: CommandFactory 创建命令处理器
- **模板方法**: Handle 基类定义命令执行流程
- **策略模式**: 不同构建配置和目标平台策略
- **观察者模式**: 构建进度和状态通知
- **建造者模式**: 复杂配置对象构建

---

## 3. 核心模块设计

### 3.1 命令系统架构

#### 3.1.1 命令工厂 (CommandFactory)
命令工厂负责根据用户输入创建对应的命令处理器：
- 支持的命令：build, clean, init, update, test, bench, check, run, tree, install, uninstall
- 参数为空时默认返回 CpmCommand（帮助命令）
- 类型安全的命令分发机制

#### 3.1.2 命令基类 (Handle)
所有命令继承的基类，定义统一的接口：
- handleCommand() - 命令执行主入口
- printHelp() - 帮助信息输出  
- printError() - 错误信息输出
- printPass() - 成功信息输出
- isHelp() - 判断是否为帮助请求

#### 3.1.3 参数解析系统
基于 std.argopt 库实现的参数解析：
- 短选项和长选项支持
- 参数验证和类型转换
- 安全检查和注入防护
- 错误提示和建议

### 3.2 构建系统核心

#### 3.2.1 构建配置 (BuildConfig)
统一的构建配置管理：
- 目标平台配置
- 编译选项和优化级别
- 输出路径和文件名
- 并行度和资源限制
- 跨平台编译支持

#### 3.2.2 依赖解析 (ModuleResolve)
完整的依赖解析系统：
- 递归依赖解析
- 循环依赖检测
- 版本冲突处理
- 拓扑排序构建顺序
- 依赖缓存和重用

#### 3.2.3 并行构建 (build_parallel.cj)
高性能并行构建实现：
- 基于依赖图的并行调度
- 原子变量控制并发数
- 工作窃取模式
- 内存压力管理

### 3.3 配置管理系统

#### 3.3.1 TOML 解析器
完整的 TOML 规范实现：
- 词法分析器（Lexer）
- 语法分析器（Parser） 
- 类型系统和值表示
- 错误处理和恢复

#### 3.3.2 配置验证
多层次的配置验证：
- 语法验证
- 语义验证
- 依赖关系验证
- 平台兼容性验证

---

## 4. 命令系统实现

### 4.1 核心命令详解

#### 4.1.1 Build 命令
最复杂的核心命令，支持多种选项：
- `-i, --incremental` - 增量编译
- `-j, --jobs <N>` - 并行构建控制
- `-V, --verbose` - 详细输出
- `-g` - 调试版本
- `--target <value>` - 跨平台编译
- `--mock` - 测试模拟支持
- `--skip-script` - 跳过构建脚本

#### 4.1.2 Test 命令
测试执行和管理：
- 测试文件自动发现
- 并行测试执行
- 过滤器和标签支持
- 测试报告生成
- 覆盖率分析

#### 4.1.3 工作空间命令
工作空间相关操作：
- 成员模块管理
- 统一构建配置
- 依赖共享
- 批量操作

### 4.2 参数处理机制

#### 4.2.1 安全验证
所有用户输入都经过安全检查：
- 路径遍历防护
- 命令注入防护
- 正则表达式验证
- 长度和格式限制

#### 4.2.2 错误处理
完善的错误处理和用户反馈：
- 详细的错误消息
- 建议和修复提示
- 多语言支持准备
- 结构化错误码

---

## 5. 依赖管理系统

### 5.1 依赖类型支持

#### 5.1.1 路径依赖
本地开发依赖支持：
- 相对路径和绝对路径
- 符号链接处理
- 实时变更监听
- 开发模式优化

#### 5.1.2 Git 依赖  
Git 仓库依赖管理：
- 支持 tag、branch、commit
- 浅克隆优化
- 缓存机制
- 网络重试和错误恢复

### 5.2 依赖解析算法

#### 5.2.1 解析流程
系统化的依赖解析过程：
1. 读取 cjpm.toml 依赖声明
2. 递归解析传递依赖
3. 构建完整依赖图
4. 循环依赖检测
5. 版本冲突分析
6. 拓扑排序
7. 生成锁文件

#### 5.2.2 冲突解决
智能的冲突解决策略：
- 版本兼容性检查
- 依赖类型一致性
- 用户决策点提示
- 自动解决建议

### 5.3 锁文件机制 (cjpm.lock)

#### 5.3.1 锁文件内容
精确的依赖版本记录：
- Git commit ID
- 文件校验和
- 依赖链信息
- 构建时间戳

#### 5.3.2 可重现构建
确保构建一致性：
- 确定性依赖版本
- 平台无关构建
- 缓存失效策略
- 环境隔离

---

## 6. 构建系统设计

### 6.1 编译器集成

#### 6.1.1 CJC 编译器调用
与仓颉编译器的集成：
- 命令行参数构建
- 进程管理和监控
- 输出解析和处理
- 错误信息转换

#### 6.1.2 跨平台编译
多目标平台支持：
- x86_64-w64-mingw32 (Windows)
- x86_64-unknown-linux-gnu (Linux)
- aarch64-unknown-linux-gnu (Linux ARM)
- x86_64-apple-darwin (macOS Intel)
- aarch64-apple-darwin (macOS ARM)

### 6.2 增量编译系统

#### 6.2.1 缓存机制
高效的增量编译缓存：
- JSON 格式缓存文件 (cjpm-cache.json)
- 文件哈希和时间戳
- 依赖关系跟踪
- 缓存失效策略

#### 6.2.2 变更检测
智能的变更检测：
- 源文件修改监控
- 配置变更检测
- 依赖更新感知
- 最小重建集合

### 6.3 并行构建引擎

#### 6.3.1 并发控制
精确的并发控制：
- maxParallelSize 全局限制
- CUR_PARALLEL_SIZE 原子计数器
- 动态负载均衡
- 资源竞争避免

#### 6.3.2 调度算法
基于依赖图的调度：
- 拓扑排序
- 关键路径分析
- 工作窃取模式
- 错误快速失败

---

## 7. 配置管理

### 7.1 配置文件系统

#### 7.1.1 主配置文件 (cjpm.toml)
项目的核心配置：
- package 元信息
- dependencies 依赖声明
- target 目标配置
- build-script 构建脚本
- ffi C/C++ 集成

#### 7.1.2 锁文件 (cjpm.lock)
确定性构建配置：
- 精确依赖版本
- 构建时元数据
- 平台特定信息

#### 7.1.3 历史文件 (.cjpm-history)
构建历史记录：
- 解析结果序列化
- 依赖图快照
- 构建时间戳

### 7.2 TOML 解析器架构

#### 7.2.1 词法分析 (lexer.cj)
TOML 词法分析实现：
- 状态机驱动
- 字符流处理
- 错误位置跟踪
- 注释和空白处理

#### 7.2.2 语法分析 (parser.cj)
递归下降解析器：
- 语法规则实现
- 错误恢复机制
- 类型推导
- 嵌套结构处理

#### 7.2.3 值类型系统
完整的 TOML 值表示：
- 基本类型：String, Integer, Float, Boolean
- 复合类型：Array, Table
- 日期时间类型
- 自定义序列化

---

## 8. 性能优化策略

### 8.1 多级缓存系统

#### 8.1.1 依赖缓存
分布式依赖缓存：
- 全局缓存：~/.cjpm/cache
- 项目缓存：target/.cache
- 内存缓存：LRU 策略

#### 8.1.2 增量编译缓存
细粒度的构建缓存：
- 文件级别缓存
- 模块级别缓存
- 依赖链缓存
- 交叉编译缓存

### 8.2 并发优化

#### 8.2.1 I/O 优化
异步 I/O 和批量操作：
- 非阻塞文件操作
- 批量依赖下载
- 并行文件解析
- 流式处理

#### 8.2.2 内存管理
高效的内存使用：
- 对象池化
- 懒加载策略
- 内存映射文件
- 垃圾收集优化

### 8.3 网络优化

#### 8.3.1 下载策略
智能的网络下载：
- 并发下载控制
- 断点续传支持
- CDN 加速
- 本地镜像支持

#### 8.3.2 缓存策略
网络缓存优化：
- HTTP 缓存头
- ETag 验证
- 压缩传输
- 增量更新

---

## 9. 安全与合规

### 9.1 输入验证

#### 9.1.1 参数验证
全面的输入验证：
- 正则表达式验证
- 长度限制检查
- 字符集限制
- 格式规范检查

#### 9.1.2 路径安全
路径操作安全：
- 路径遍历防护
- 符号链接检查
- 权限验证
- 沙箱限制

### 9.2 权限管理

#### 9.2.1 文件权限
细粒度权限控制：
- 读写执行权限
- 所有者和组权限
- 临时文件清理
- 安全创建模式

#### 9.2.2 进程权限
进程执行安全：
- 最小权限原则
- 环境变量过滤
- 命令行清理
- 子进程监控

### 9.3 依赖安全

#### 9.3.1 校验机制
依赖完整性验证：
- SHA 校验和
- 数字签名验证
- 来源验证
- 恶意代码检测

#### 9.3.2 隔离机制
构建环境隔离：
- 临时目录隔离
- 网络访问控制
- 系统调用限制
- 资源使用限制

---

## 10. 扩展性设计

### 10.1 脚本系统

#### 10.1.1 构建脚本 (build_script.cj)
灵活的构建脚本系统：
- pre-build 和 post-build 钩子
- 多语言脚本支持
- 环境变量传递
- 错误处理和恢复

#### 10.1.2 自定义命令
可扩展的命令系统：
- 插件式命令注册
- 参数解析复用
- 帮助系统集成
- 权限继承

### 10.2 FFI 支持

#### 10.2.1 C/C++ 集成
完整的 FFI 支持：
- 头文件处理
- 库文件链接
- 编译标志传递
- 跨平台适配

#### 10.2.2 构建工具链
外部工具集成：
- Make、CMake 支持
- 自定义构建系统
- 工具链配置
- 版本管理

### 10.3 工作空间系统

#### 10.3.1 多模块管理
工作空间功能：
- 成员模块定义
- 依赖关系管理
- 统一构建配置
- 批量操作支持

#### 10.3.2 配置继承
层次化配置系统：
- 工作空间级配置
- 模块级配置
- 用户级配置
- 环境级配置

---

## 12. 现有实现分析

### 12.1 架构优势

#### 12.1.1 模块化设计
当前实现的良好架构：
- 清晰的模块分离
- 职责单一原则
- 可测试性设计
- 扩展点预留

#### 12.1.2 完整功能覆盖
功能完备性：
- 完整的 TOML 解析器
- 全面的命令支持
- 跨平台兼容
- 工作空间管理

### 12.2 改进空间

#### 12.2.1 性能优化机会
潜在的性能提升点：
- 内存使用优化
- 并发处理改进
- I/O 操作优化
- 缓存策略优化

#### 12.2.2 开发体验提升
开发效率改进：
- 类型安全增强
- 错误处理改进
- 调试工具完善
- 文档和示例丰富

---

## 13. 结语

CJPM 作为仓颉语言生态的基础设施，承载着包管理、构建系统、工具链集成等核心功能。当前的仓颉实现已经具备了完整的功能和良好的架构设计，为 Kotlin 重构提供了坚实的基础。

通过 Kotlin 重构，我们将：
- **提升性能**：利用 JVM 生态和 Kotlin 协程实现更高效的并发处理
- **增强可维护性**：现代化的类型系统和工具链支持
- **扩展生态**：更好的 IDE 集成和第三方库支持
- **保证兼容性**：平滑的迁移路径和向后兼容

KCJPM 将继承 CJPM 的设计理念，在保持功能完整性的同时，为仓颉语言开发者提供更加现代化、高效和易用的包管理体验。